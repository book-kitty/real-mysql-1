# 인덱스
> 인덱스란? 책의 찾아보기와 같은 것이다. 찾아보기를 통해 원하는 책의 내용을 빠르게 찾는 것과 비슷한 맥락이다.  
> 책의 찾아보기가 인덱스라면, 찾을 책의 내용은 데이터가 될 수 있다.

- 특정 필드를 인덱스로 설정하면, 해당 필드는 내부적으로 인덱스 파일에 정렬되어 저장된다.
- 인덱스 파일에는 정렬된 필드의 데이터들과 필드가 저장된 데이터의 주소가 key-value 형식으로 저장되어 있다.
- MySQL은 인덱스를 B-Tree 구조로 관리한다. 
- 인덱스는 INSERT, UPDATE, DELETE 기능을 희생하고 SELECT 성능을 높여주는 역할을 한다.
- 읽기보다 데이터 변경이 빈번하다면 인덱스를 추가하는 것이 좋지않은 선택일 수도 있다.
- PK는 따로 지정하지 않아도 인덱스로 등록된다. PK를 제외한 인덱스를 세컨더리 인덱스라고 한다.
- 인덱스 파일의 데이터 변경은 백그라운드로 진행되기 때문에 사용자의 쿼리요청이 인덱스 파일 변경 때문에 지연되는 경우는 드물다.

## B-Tree (Balanced Tree)
> B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘  
> 컬럼 값의 Prefix 값을 기준으로 정렬되기 때문에 LIKE 의 앞부분 일치 조회로도 인덱스를 사용할 수 있다. 

### 구조 및 특성
> B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 위에 하위 자식노드가 붙어있는 형태이다.  
> 트리 구조의 가장 하위에 있는 노드를 리프 노드라고 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 노드를 브랜치 노드라고 한다.  
> 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 읽어와야 한다.
- 조회하는 필드가 커버링 인덱스만으로도 조회가 가능한 경우, 데이터 파일에서 레코드를 읽지 않고 커버링 인덱스로 대체한다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리키가 ROWID의 역할을 한다. InnoDB의 세컨더리 인덱스는 물리적 주소를 갖는게 아닌, 프라이머리키를 가지고 있다.
- InnoDB 에서 모든 세컨더리 인덱스는 검색에서 데이터 레코드를 읽기 위해서 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다. 

### B-Tree 인덱스의 키 추가 및 삭제

**1. 추가**
- InnoDB 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수 있고 그렇지 않을 수도 있다.
  - 프라이머리키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.
- B-Tree에 저장될 때는 적절한 위치를 탐색하고 저장해야한다. 리프 노드가 꽉 차서 저장할 공간이 없을 때는 리프 노트가 split 되어야 한다.
  - 이는 상위 브랜치 노드까지 처리의 범위가 넓어짐
  - 이러한 특성 탓에 B-Tree는 추가 비용이 많이 드는 것으로 알려져있음

**2. 삭제**
- B-Tree의 키 값 삭제는 간단하다. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.
- 삭제 마킹된 인덱스의 키 공간은 계속 그대로 두거나 재활용 할 수 있다. 삭제 마킹 또한 디스크 I/O가 필요한 작업이다.
  - 삭제 마킹도 버퍼링되어 처리할 수 있음

**3. 변경**
- 인덱스의 키 값에 따라 저장될 리프 노드의 위치가 결정되므로 단순히 인덱스상의 키 값만 변경하는 것은 불가능 하다.
- B-Tree의 키 값 변경은 먼저 키 값을 삭제하고 다시 새로운 키 값을 추가하는 형태로 처리되낟.
  - 체인지 버퍼를 통해 지연처리가 가능

**4. 인덱스 키 검색**
- 인덱스를 검색하는 작업은 B-Tree의 루트 노드 -> 브랜치노드 -> 리프 노드 까지 이동하면서 비교작업을 수행한다. `(트리탐색)`
- 인덱스 트리 담색은 SELECT 뿐만 아니라 UPDATE, DELETE 에서도 해당 인덱스를 검색 조건으로 사용할 경우에도 탐색한다.
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분만 일치하는 경우에 사용할 수 있다. 뒷부분만 검색할 경우에는 사용이 불가능하다.
- 인덱스의 키 값에 변형을 가하고 검색할 경우 B-Tree의 빠른 검색 기능을 사용할 수 없다.

```text
InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락은 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠구는 식으로 구현되어있다.
따라서 UPDATE나 DELETE 문장이 실행될 떄 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.
심지어 테이블의 모든 레코드를 잠글 수도 있다. 
```

### B-Tree 인덱스 사용에 영향을 미치는 요소
> 칼럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

**인덱스 키 값의 크기**
- 인덱스는 페이지 단위로 관리된다. 루트, 브랜치, 리프 노드를 구분한 기준도 페이지 단위이다. 
- B-Tree가 가질 수 있는 자식 노드의 수는 가변적이고 페이지 크기와 값의 크기에 따라 달라진다. 
- 인덱스의 키가 16Byte이고 인덱스 페이지의 크기가 16KB일 경우 `16*1024/(16+12) = 585개`를 저장할 수 있다.
- 인덱스의 키 크기가 커질 수록 인덱스가 여러 페이지에 저장되게 된다. 이경우 원하는 인덱스를 찾기위해 여러 인덱스 페이지를 탐색하는 일이 발생할 수 있다.

**B-Tree 깊이**
- 인덱스 키 값이 16Byte이고 B-Tree의 깊이가 3인 경우 최대 2억(585*585*585)개 정도의 키 값을 담을 수 있다.   
- B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
- 인덱스의 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다.
- 같은 데이터 건수더라도 인덱스 키 값 크기에 따라 깊이가 달라질 수 있다. 

**선택도(기수성)**
> 선택도란 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.  
> 전체 인덱스 키 값은 100개인데 그중에서 유니크한 값이 10개라면 기수성은 10이 된다.

**읽어야 하는 레코드의 건수**
- 인덱스를 통해 레코드를 읽는 것은 테이블에서 직접 레코드를 읽는 것보다 4~5배 정도 비용이 더 많이 든다.
- 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지않고 테이블을 직접 모두 읽어서 필요한 레코드만 가려내는 필터링 방식을 이용하는 것이 효율적

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔
> 인덱스 레인지 스캔은 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방법
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

### 인덱스 풀 스캔
> 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만, 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 의미  
> 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 적용된다.  
> 일반적으로 인덱스의 크기는 테이블보다 작으므로 직접 테이블을 전부 읽는 것보다는 빠르지만 인덱스를 이용한 계획 중 그다지 좋은 실행계획은 아니다.

### 루스 인덱스 스캔
> 루스 인덱스 스캔은 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.   
> 루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 동작하지만, 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한ㄷ.  
> 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는경우에 사용된다.

### 인덱스 스킵 스캔
> 루스 인덱스 스캔은 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용될 수 있다.  
> 그러나 MySQL 8.0 부터 도입된 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능하도록 용도가 훨신 넓어진 것이다.
- 인덱스 스킵 스캔은 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화.
- 인덱스 스킵 스캔을 이용하러면 인덱스의 존재하는 칼럼만으로 처리가 가능해야 한다(커버링 인덱스)
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야한다.
- 인덱스 루스 스캔과 동일한 방식으로 읽으면서 인덱스에 존재하는 모든 값을 먼저 추출하고 그 결과를 이용해 인덱스 스킵 스캔을 이용함

### 다중 칼럼 인덱스
- 다중 칼럼 인덱스는 인덱스의 앞쪽 칼럼에 의존해서 정렬된다. 즉 두번쨰 칼럼은 첫번째 칼럼에 의존하고 세번째 칼럼은 두번째 칼럼에 의존하게 된다.
- 두번째 칼럼의 정렬 순서가 빠르더라도 첫번째 칼럼의 정렬 순서가 늦다면, 인덱스 뒤쪽에 위치한다. 
- 이러한 특성 때문에 다중 칼럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요하다. 

## 인덱스 스캔 방향
> 인덱스 역순 스캔 : 인덱스 키의 크고 작음에 관계없이 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔  
> 인덱스 정순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
> 
> 인덱스의 역순 스캔은 인덱스의 정순 스캔보다 28.9% 정도의 시간이 더 소요된다.  

많은 쿼리가 인덱스의 앞쪽만 혹은 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로  
예상되면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 된다. 

### 내림차순 인덱스
> 내림차순 인덱스는 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬됨
- 내림차순 인덱스에서 정순(DESC) 스캔할 경우 오른쪽으로 스캔하게 된다. 
- 내림차순 인덱스에서 역순(ASC) 스캔할 경우 왼쪽으로 스캔하게 된다. 

### 오름차순 인덱스
> 오름차순 인덱스는 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬됨
- 내림차순 인덱스에서 정순(ASC) 스캔할 경우 오른쪽으로 스캔하게 된다.
- 내림차순 인덱스에서 역순(DESC) 스캔할 경우 왼쪽으로 스캔하게 된다.


### 역순 스캔이 더 느린이유
1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조 

## 인덱스를 사용할 수 없는 경우

### B-Tree 특성상 인덱스를 사용할 수 없는 경우
1. NOT-EQUAL로 비교된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
2. LIKE "%??(앞부분이 아닌 뒷부분 일치)" 형태로 문자열 패턴이 비교된 경우 
3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
6. 문자열 데이터 타입의 콜레이션이 다른 경우 

### 다중 칼럼으로 만들어진 인덱스가 사용될 수 없는 경우
> ex) INDEX ix_test (colum_1, column_2, column_3)

1. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
  - column_1 칼럼에 대한 조건이 없는 경우
  - column_1 칼럼의 비교 조건이 인덱스 사용 불가 조건 중 하나인 경우
2. 작업 범위 결정 조건으로 인덱스를 사용하는 경우
   - column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태("=" or "IN")로 비교
   - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
     - 동등 비교
     - 크다 작다 형태
     - LIKE로 좌측 일치 패턴 (LIKE '승환%')

## R-Tree 인덱스
> R-Tree 인덱스란 2차원의 데이터를 인덱싱하고 검색하는 것이 목적인 인덱스  
> 내부 매커니즘은 B-Tree와 흡사하다. R-Tree는 인덱스를 구성하는 값이 2차원의 공간 개념 값이다.

### 구조 및 특성
> MBR(Minimum Bounding Rectangle)은 해당 도형을 감싸는 최소 크기의 사각형을 의미한다.  
> R-Tree은 MBR의 그룹에 따라 노드가 나뉜다. 
- R-Tree의 노드는 MBR의 그룹에 따라 나뉜다.
- 최상위 MBR은 루트노드, 차상위 그룹은 브랜치노드, 각 도형의 객체는 리프노드에 저장된다.

### R-Tree 인덱스의 용도
> R-Tree는 위도 경조 좌표 저장에 주로 사용된다. 위경도 좌표뿐 아니라 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.  
> 대표적으로는 '현재사용자의 위치로부터 반경 5km이내의 음식점 검색'등과 같은 검색에 사용할 수 있다. 
- ST_Contains(), ST_Within() 함수는 사각형 박스와 같은 다각형으로만 연산할 수 있음
- ST_Contains(), ST_Within() 함수는 반대로 사용해야 함
- ST_Contains() 함수는 첫번째 인자로 포함 경계를 가진 도형을 명시하고 두번쨰로는 파라미터로 포함되는 도형또는 좌표를 명시
- ST_Within() 함수는 첫번째 인자로 좌표를 명시해야하고 두번째 인자로 포함 경계를 가진 도형을 명시해야 함

## 함수 기반 인덱스
> MySQL 8.0부터는 함수 기반 인덱스를 지원한다.  
> 함수기반 인덱스는 칼럼의 값을 변형해서 만들어진 값에 대해서 인덱스 처리가 가능하도록 한다.  
> 함수기반 인덱스를 활용하려면 인덱스로 등록한 표현식이 그대로 사용되어야 한다. 
- MySQL 5.7 이전에는 가상 칼럼을 이용하여 비슷한 효과를 낼 수 있었지만, 이는 실제 테이블 구조도 변경되는 단점이 있다.
- MySQL 8.0 부터는 테이블 구조를 변경하지 않고 함수 기반 인덱스를 직접 생성할 수 있다. 

## 멀티 밸류 인덱스
> 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스  
> MySQL 8.0 부터 JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 처리가 mongoDB에 비해서도 부족함이 없어짐 
- 멀티 밸류 인덱스를 이용하려면 반드시 아래의 함수로 실행해야 옵티마이저가 인덱스를 활용한 실행계획을 수립한다.
  - MEMBER OF()
  - JSON_CONTAINS()
  - JSON_OVERLAPS()
- MySQL 8.0.21 버전에서는 CHAR/VARCHAR 타입에 대해서는 지원하지 않는다. 

## 클러스터링 인덱스
> 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준)들끼리 묶어서 저장하는 형태로 구현된다.  
> 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다. MySQL에서는 InnoDB 엔진에서만 지원된다.  
> InnoDB는 프라이머리 키를 생성하지 않아도 내부적으로 사용자에게 보이지 않는 클러스터링 키를 생성한다.    
> 내부적으로 생성된 클러스터링 키는 사용자가 이용할 수 없고 어떠한 장점도 주지않기 때문에 PK를 생성하는 것이 이득이다.

### 클러스터링 인덱스
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.
- 프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크다.
- 테이블의 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 `클러스터링 인덱스` 또는 `클러스터링 테이블` 이라고 한다.
- 클러스터링 인덱스의 리프노드는 클러스터 키 값을 기준으로 정렬되어 있고 테이블에 모든 데이터가 담겨있다. 
- InnoDB에서 PK의 값이 변경되면 클러스터링 테이블에서 재배치가 이뤄져야 한다.

### 프라이머리 키가 세컨더리 인덱스에 미치는 영향
- 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.
- 세컨더리 인덱스가 실제 레코드의 주소를 가질 경우 클러스터링 테이블의 값이 변경될 때마다 해당 테이블의 모든 인덱스에 저장된 주소값을 변경해야할 수 있다.
- 세컨더리 인덱스의 값을 탐색할 때 프라이머리 키 인덱스를 검색하여 최종 레코드를 가져오는 추가작업이 있지만, 프라이머리 키는 더 큰 장점을 제공한다.

### 클러스터링 인덱스의 장점과 단점
**장점**
- 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 떄문에 인덱스만으로 처리될 수 있음 (이를 커버링 인덱스라고 함)
- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름 특히 프라이머리 키를 범위 검색하는 경우 매우 빠름

**단점**
- 프라이머리 키를 변경할 떄 레코드를 DELETE 하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
- INSERT 할 떄 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 테이블의 모든 세컨더리 인덱스가 클러스터링 기를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스가 커짐
  - `인덱스의 크기 : 레코드 수 * 프라이머리키 크기`
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림

## 유니크 인덱스
> 유니크 인덱스는 인덱스라기보다 제약조건에 가깝다. MySQL 에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.   
> 유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정값이 아니므로 2개 이상 저장될 수 있다. 

### 유니크 인덱스와 일반 세컨더리 인덱스 비교
- 유니크 인덱스와 세컨더리 인덱스의 성능 차이는 거의 없다.
- 유니크하지 않은 인덱스는 단지 데이터량이 더 많아질 수밖에 없는 구조이기 때문에 데이터 탐색 시간이 더 걸릴 것 뿐이다.
- 유니크 인덱스는 중복 체크를 필수로 해야하기 때문에 체인지 버퍼를 이용할 수 없다. 이러한 이유로 세컨더리 인덱스보다 쓰기 작업이 느리다.
- 유니크 인덱스도 세컨더리 인덱스와 같은 역할을 동일하게 수행할 수 있으므로 중복된 인덱스를 만들 이유는 없다. 

## 외래키
> 외래키 제약이 설정되면 자동으로 연괸되는 테이블의 칼럼에 인덱스까지 설정된다.  
> 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

### 외래키 관리에 중요한 두 가지
- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생 시키지 않는다.

**자식 테이블이 대기하는 경우**
```sql
1. UPDATE tb_parent SET fd 'change-2' WHERE id = 2;

2. UPDATE tb_child SET pid = 2 WHERE id = 100;
```
1번 트랜잭션이 먼저 시작되었다고 가정했을 때 2번 트랜잭션은 1번 트랜잭션이 완료될 때까지 대기해야 한다.  
즉 자식 테이블의 외래 키 칼럼의 변경은 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해제될 때까지 대기해야 한다.


**부모 테이블이 대기하는 경우**
```sql
1. UPDATE tb_child SET fd 'change-100' WHERE id = 1;

2. DELETE tb_parent WHERE id = 1;
```
1번 트랜잭션이 먼저 시작되었다고 가정했을 때 2번 트랜잭션은 1번 트랜잭션이 완료될 때까지 대기해야 한다.  
tb_parent가 참조된 로우의 레코드를 삭제하는 경우 이 쿼리는 tb_child 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기다려야 한다.  
이는 tb_child가 생성될 때 정의된 외래키 특성 (ON DELETE CASCADE) 때문에 부모 케로드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문이다.  
만약 `ON DELETE CASCADE`가 설정되어 있지 않다면 잠금 전략에 따라 달라질 수 있다.
  