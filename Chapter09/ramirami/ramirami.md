## 옵티마이저와 힌트

### 옵티마이저의 종류

- **규칙기반 최적화**
    - 통계 정보등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    - 통계 정보를 조사하지 않고 실행계획을 도출하기 때문에 같은 쿼리에 대해선 항상 동일한 실행 방법을 만든다.
    - 규칙 기반 최적화는 이미 오래전부터 많은 DBMS에서 사용되지 않는다.

- **비용기반 최적화**
    - 쿼리의 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용하여 계획을 산출한다.
    - 통계 정보를 통해 산출된 실행 방법별로 비용이 최소로 소요되는 처리방식을 선택해 최종적으로 쿼리를 실행한다.
    - MySQL은 비용기반 옵티마이저를 채택한다.

### 풀 테이블 스캔과 풀 인덱스 스캔

- **옵티마이저가 풀 테이블 스캔을 하는 경우**
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 사용하는 것이 더 느린 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있더라도 옵티마이저가 판단한 레코드 건수가 너무 많은 경우
  - 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. 


### InnoDB의 Read-ahead
> InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해  
> `Read-ahead` 작업이 자동으로 실행된다. 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라 예측하고  
> 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미한다.  
> `Read-ahead`는 테이블 풀 스캔 뿐만 아니라 인덱스 스캔에서도 동일하게 사용될 수 있다. 

### 레코드 건수 조회 인덱스 사용
```SQL
SELECT COUNT(*) FROM employees;
```
예시 쿼리는 아무런 조건없이 employees 테이블의 레코드 수를 조회하기에 테이블 풀 스캔을 할 것처럼 보인다.  
그러나 실제로는 풀 인덱스 스캔을 할 가능성이 높다. 단순히 레코드의 수를 조회하는 쿼리라면 용량이 적은 인덱스를 조회하는 것이  
성능에 더 이득이 될 수 있기 때문이다. 

### 병렬처리
- MySQL 8.0 부터는 하나의 쿼리를 병렬로 수행할 수 있게 되었다. 
- innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다. 
- 병렬처리용 스레드를 늘리더라도 서버의 CPU 수보다 많게 설정할 경우 오히려 성능을 저하시킬 수 있으니 주의하자.
  - 작업을 너무 작은 단위로 나눴을 경우 CPU 경쟁으로 인해 성능이 저하될 수 있을 것 같다. 

### ORDER BY 처리 (Using filesort)

|             | 장점                                                                                            | 단점                                                                                                                      |
|-------------|-----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|
| 인덱스 이용      | INSERT, UPDATE, DELETE 쿼리가 실행될 떄 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.                     | 쓰기 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 그리고 인덱스 이용으로 인해 디스크 공간이 더 많이 필요하다. 인덱스의 개수가 늘어날 수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다. |
| Filesort 이용 | 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레크드 대상 건수가 많아질수록 쿼리의 응답속도가 느리다.                                                                    |


### 소트 버퍼
> MySQL은 정렬을 수행하기 위해 소트 버퍼라는 메모리 공간을 할당받아서 사용한다.  
> 소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야할 레코드의 크기에 따라 가변적으로 증가한다.
> 그러나 최대 사용 가능한 소트 버퍼 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.
> 정렬할 레코드가 최대 사용 가능한 소트 버퍼 공간보다 클 경우 디스크를 이용하여 정렬을 수행해야 한다. 
> 소트 버퍼는 사용되고나면 즉시 시스템으로 반납된다. 

**소트 버퍼를 용량을 초과한 데이터를 정렬하는 순서** 
1. 메모리의 소트 버퍼에서 정렬을 수행
2. 결과를 임시로 디스크에 기록
3. 다시 다음 레코드를 가져와서 정렬을 수행, 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬
4. 정렬이 완료될 때까지 반복적으로 1,2번을 작업을 수행 함

### 싱글 패스 방식
- 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼을 전부 담아서 정렬을 수행하는 방식
- 테이블을 두번 조회하지 않아도 되기 때문에 더블 패스 방식보다 일반적으로 빠른 성능을 보임
- 싱글 패스 방식은 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임

### 더블 패스 방식
- 정렬 대상과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행
- 정렬이 완료되면 정렬된 순서대로 다시 프라이머리 키를 이용하여 테이블을 읽고 SELECT 할 컬럼을 가져옴
- 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적
- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 저장된 크기보다 클 때 이용
- BLOB이나 TEXT 타입의 컬럼이 SELECT에 포함될 때

### 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬을 이용하려면 아래 조건을 만족해야 한다.
  1. ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블 (조인이 사용된 경우 드라이빙 테이블)
  2. ORDER BY 순서대로 생성된 인덱스가 있어야 함
  3. WHERE절에 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있을 경우 ORDER BY와 같은 인덱스를 사용해야 함
- 여러 테이블이 이용되는 경우 네스티드-루프 방식의 조인에서만 사용이 가능함
- B-Tree 계열의 인덱스에서만 사용이 가능함 
- 조인이 사용된 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있음

### 조인의 드라이빙 테이블만 정렬
- 조인에서 첫 번쨰로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 함
- 이 경우 옵티마이저는 `드라이빙 테이블만` 검색해서 `정렬을 수행`하고 그 결과와 `드리븐 테이블`을 조인한다.

### 임시 테이블을 이용한 정렬
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야할 경우 임시 테이블을 이용해야할 수 있다.
- 임시 테이블을 이용한 정렬은 세가지 방법 중 정렬해야할 레코드가 가장 많기 때문에 느리다.  

### 정렬 처리 방법의 성능 비교
- ORDER BY나 GROUP BY를 이용할 경우 두 작업을 모두 수행하고 LIMIT으로 건수를 제한할 수 있다.
- WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 ORDER BY나 GROUP BY 때문에 느려질 수 있다.

### 스트리밍 방식
> 서버에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다  
> 바로바로 클라이언트에게 전송해주는 방식을 `스트리밍 방식`이라고 한다. 

**JDBC의 스트리밍 방식 처리**  

```text
JDBC는 스트리밍 방식으로 데이터를 받지만 마지막 레코드가 전달 될 때까지 내부 버퍼에 데이터를 담아 놓는다.  
JDBC가 이러한 방식을 채택한 이유는 이 방식이 전체 처리 시간이 짧고 MySQL과 통신 횟수가 줄어 자원 소모가 줄어들기 떄문이다.  
JDBC와 MySQL 서버가 대화형으로 데이터를 주고받는 것이 아니라 MySQL은 데이터 크기에 상관없이 보내기만 하고 JDBC는 저장만 하기 떄문에  
불필요한 네트워크 요청이 최소화 되어 전체 처리량이 뛰어난 것이다.  
```

### 버퍼링 방식
> ORDER BY나 GROUP BY를 이용하면 쿼리 결과가 스트리밍 되는 것을 `불가능`하게 한다.  
> 버퍼링 방식을 이용하면 MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지못하고 기다려야 한다.

### 인덱스 스캔을 이용하는 GROUP BY
GROUP BY가 인덱스를 이용하여 정렬하는 경우 이미 정렬된 인덱스를 읽는 것이므로 추가적인 정렬 작업이나 내부 테이블을 사용하지 않아도 된다.  
그러나 GROUP BY가 그룹 함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요한 경우도 있다. 


### 루스 인덱스 스캔을 이용하는 GROUP BY
루스 인덱스 스캔을 이용한 GROUP BY는 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.   
또한 프리픽스 인덱스는 루스 인덱스 스캔을 사용할 수 없다. 그리고 인덱스 레인지 스캔에선 유니크한 값의 수가 많을수록 성능이 향상되면 반면  
루스 인덱스 스캔에선 인덱스의 유니크한값이 적을수록 성능이 향상된다. 이는 유니크한 값이 많을수록 스킵하지 못하는 로우가 많기 떄문이라고 추측된다. 

### 임시 테이블을 사용하는 GROUP BY
GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 떄 이용된다.  
MySQL 8.0 버전 이전에는 GROUP BY가 사용된 쿼리는 그루핑 되는 칼럼을 기준으로 묵시적인 정렬까지 함께 수행했지만,  
MySQL 8.0 부터는 이 같은 묵시적인 정렬은 더 이상 실행되지 않게 바뀌었다.  

### SELECT DISTINCT 
DISTINCT는 `SELECT DISTINCT(col1, col2), co3` 이와 같은 쿼리를 작성했을 때 col1과 col2 컬럼에 대해서만 중복처리를 하는게 아닌,  
조회 조건의 모든 컬럼의 조합이 중복되지 않도록 필터링 한다. 하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수에 전달된 컬럼값이 유니크한 것만 가져온다.  

### 임시테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 컬럼이 다른 경우
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리 (selelct_type 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

**일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느리다.**

### 블록 네스티드 루프 조인
- MySQL 서버에서 사용되는 대부분의 조인은 `네스티드 루프 조인`이다.
- 네스티드 루프 조인은 조인의 연결 조건이 있는 컬럼에 모두 인덱스가 있는 경우 사용된다. 

### 조인버퍼
- 어떤 방식으로도 드리븐 테이블의 풀 스캔이나 인덱스 풀 스캔을 피할 수 없는 경우 조인 버퍼를 이용하게 됨
- 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리 됨 이떄 사용되는 메모리 캐시가 `조인 버퍼`
- 조인 버퍼를 이용하면 드라이빙 테이블을 조인 버퍼에 담아두고 드리븐 테이블을 먼저 읽은다음 조인 버퍼에서 일치하는 레코드를 찾는 형식으로 수행됨
  - 이러한 방식 때문에 조인 버퍼를 이용하면 결과의 정렬 순서가 흐트러질 수 있음